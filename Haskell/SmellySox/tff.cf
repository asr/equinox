
entrypoints Tffs ;

comment "%";

Tffs.  Tffs  ::= [Tff];

terminator Tff "." ;

TffIncl. Tff ::= "include" "(" FPath ")" ;
TffTyp. Tff  ::= "tff" "(" Ident "," "type" "," "(" Ident ":" Type ")" ")";
Tff.    Tff  ::= "tff" "(" Ident "," ClauseType "," Expr ")";

token FPath '\'' ('/' | '_' | '^' | '.' | letter | digit)* '\'';

CTDef.   ClauseType ::= "definition";
CTAxiom. ClauseType ::= "axiom";
CTConj.  ClauseType ::= "conjecture";

ETyp. ETyp ::= UIdent ":" Type;

EOr.      Expr   ::= Expr1 "|" Expr  ;
EAnd.     Expr1  ::= Expr2 "&" Expr1 ;
EImplies. Expr2  ::= Expr3 "=>" Expr2 ;
EEquiv.   Expr2  ::= Expr3 "<=>" Expr2 ;
EEq.      Expr2  ::= Term "=" Term ;
ENeq.     Expr2  ::= Term "!=" Term ;

EForAll.  Expr3  ::= "!" "[" [ETyp] "]" ":" Expr3 ;  
EExists.  Expr3  ::= "?" "[" [ETyp] "]" ":" Expr3 ;
ENeg.     Expr3  ::= "~" Expr4;
ETrue.    Expr4  ::= TTrue;
EFalse.   Expr4  ::= TFalse;
ELit.     Expr5  ::= Atom;

TConst.   Term ::= Ident;
TVar.     Term ::= UIdent;
TFun.     Term ::= Ident "(" [Term] ")";

APred.    Atom ::= Ident "(" [Term] ")";
AConst.   Atom ::= Ident;

separator Term ",";

token TTrue  '$' 't' 'r' 'u' 'e';
token TFalse '$' 'f' 'a' 'l' 's' 'e';

token UIdent upper (letter | '_' | digit)*;

coercions Expr 5;

TypFun.    Type  ::= Type1 ">" Type2;
TypTup.    Type1 ::= Type1 "*" Type;

TypId.     Type2 ::= TypIdent;
TypId2.    Type2 ::= Ident;

coercions Type 3;

token TypIdent '$' ('_' | letter | digit)*; 

separator ETyp ",";
